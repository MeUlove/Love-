#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m,s;
int g[1000010],tot;
struct shu
{
    int to;
    int next;
}e[1000010];
void addedge(int a,int b)
{
    tot++;
    e[tot].to=b;
    e[tot].next=g[a];
    g[a]=tot;
}
int par[1000010][30],v[1000010],dep[1000010];

void dfs(int a,int pre)                 //初始化 
{ 
    par[a][0]=pre;             //par[a][0]即为距离点a 2^0，即距离a 1步的点是哪个 
    dep[a]=dep[pre]+1;           //pre为点a的父节点，点a的深度是pre的深度+1 
    v[a]=1;                     //确保不会从这个点向上跑 
    for(int i=1;(1<<i)<=dep[a];i++)par[a][i]=par[par[a][i-1]][i-1];
    //原理就是 从点a走2^i步，可以分为先走2^(i-1)步，再走2^(i-1)步
    //而这一步是在预处理，通过par[a][0]可以得到一步一步走的点，然后预处理出从这个点走2^i步所到的点 
    int tmp=g[a];
    while(tmp!=0)
    {
        if(v[e[tmp].to]==0)        //不可以向上跑 
        {
            dfs(e[tmp].to,a);      //递归调用，继续跑下一个点，直到整棵树都跑完 
        }
        tmp=e[tmp].next;
    }
}
int lca(int u,int v)              //求lca 
{
    if(dep[u]>dep[v])swap(u,v);    //保证v是较深的点，u是较浅的点
     
    for(int j=20;j>=0;j--)  
    {
        if(dep[v]-dep[u]<=0)break;
        if((dep[v]-dep[u])>>j&1)
        {
            v=par[v][j];
        }
    }
    
    if(u==v)return u;
    
    for(int j=20;j>=0;j--)
    {
        while(par[v][j]!=par[u][j])
        {
            u=par[u][j];
            v=par[v][j];
        }
    }
    
    return par[v][0];
}
int main()
{
    scanf("%d %d %d",&n,&m,&s);
    for(int i=1;i<=n-1;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        addedge(x,y);              //无向图 
        addedge(y,x);
    }
    dfs(s,s);              //初始化 
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        printf("%d\n",lca(x,y));
    }
    return 0;
} 
